"""
    303
    상태 : 좌표
    상태변화 : 1.하우방향 2.높이가 낮은 지점으로만 이동
        수정
            상태 : 좌표
            상태변화 : 1.모든방향 2.높이가 낮은 지점으로만 이동

    바로 떠오르는 생각은 사실, 이 문제 태그를 예전에 dp라고 본적이 있어서
    dp스러운 풀이가 떠오름(정확하진 않지만)

    dfs를 하는데, 노드에 도착할때마다, 상하좌우 다 꺼내서 유효성검사를 하면 시간이 많이 걸릴 것 같다.
    먼저 상하좌우 이동여부를 기록해놓고,
        여기서 시간 많이 망설인 이유 :
            될까? 의심 -> 의심이 들어도, 먼저 일단'가정'(+그림 그리기)하고 관찰하는 습관을 빨리 들여야한다.
    319 화살표 그림 그렸음
        솔직히 지금 드는 생각은 '상하좌우'이동 여부를 1111 등으로 비트마스킹한다음에 방향배열에 넣으면 되지 않을까 생각들었던 것을
        태그 미리 확인하고, 비트마스킹이 없어서, 아 이건 아닌데, 난 이거밖에 생각이 안난다. 그래서 망설이고 있었음

    'dfs를 하는데, 노드에 도착할때마다, 상하좌우 다 꺼내서 유효성검사를 하면 시간이 많이 걸릴 것 같다.'
        사실 1.태그미리 봄 2.느낌상의 추측이지. 근거 없음. 수도코드 템플릿 짜보고 시간이 넘는다는 사실을 직접 확인하자. 답이 아닌걸 알아도
        def dfs() :
            #목표도달검사

            for i in range(4) :
                nx, ny

                if : #범위검사
                    if 유효성검사 - 내려갈 수 있을지

        확인해봤는데, 내가 생각했던 부분에서 시간이 오래걸리는 것이 아니였음.
            다음에 이런 실수 안하기 위해서
                1.모든문제 태그 아예 미리 보지 않는다.
                2.아이디어 결정(ex : 방법론 배제 like 노드에 도착할때마다 상화좌우 다 꺼내서 유효성검사하면 시간이 많이 걸릴 것)
                    은 '완벽한'설명을 진행한 뒤에 넘어간다.
    
    지금 떠오른 아이디어
        3차원배열 vis[x][y][방향]에 경로개수 기록
        제일 높은 곳(50)에 1
        문제를 다시 전체를 읽어보니, 답의 개수(경로 개수)가 3개란다
            경로 개수에 대한 의미를 명확하게 알지 못한 상태였음
        * 문제분석 - 1.문제읽기 - how. 테케 입출력을 모두 본 뒤에, 판단

    344 시간 많이 지났으므로 답지?
    352 답지를 봤는데, dp와 거리를 둔지 꽤 오래되서, dp기본코드 자체도 모르고 있었음. 그래서 해를 봐도 이해가 잘 안가고 있었음
        상황 : 오랜만에 푸는 알고리즘 분류 -> 기본 문제 틀부터 제대로 알고 있나 확인(ex : bottom-up 기본 코드 틀)

        dp - 분류 : botttom-up, top-down
                   재귀 / for문

        DP 사용 조건 : 전체 문제의 최적해가 부분 문제의 최적해로 나누어지는가
            전체문제 최적해(시작점에서부터 도착점으로 가는 경로의 수)를 구하는 문제에서,
            부분문제 최적해(임의의 점(x, y)에서 도착점 까지의 경로의 수)를 구하는 문제로 세분화 하여 구한다면,
        그 어떤 경로로 (x, y)에 도착 하기만 해도 그 때부터의 경우의 수는 다시 구할 필요가 없다.

        447 답지 분석하는데, 이해가 어려워서 dp에 대한 어느정도 숙련도가 있어야 이 문제를 이해할 수 있지 않을까라는 생각이 듬.
        dp 기본개념부터 다시 떠올려보자면, '이미 구한 경우의수를 다시 구하지 않는'
    
        #이동전 좌표2목표지점까지의 경로의수 = 이동전 좌표2목표지점까지의 경로의수 + 이동후 좌표2목표지점까지의 경로의수
        라고 한글로 풀어내니깐, 얼추 이해가려하는거 같긴한데, 단번에 이해되지 않았다
        2 -> 1 의 그림을 그리니깐 또 이해가 가는 것 같다.
        |    |
        1 -> 1

"""

import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 9)

m, n = map(int, input().split())
maps = [list(map(int, input().split())) for i in range(m)]
dp = [[-1]*n for i in range(m)] #

dx = [0, 1, 0, -1]
dy = [1, 0 , -1, 0]

#bottom-up 재귀
def solution(x, y): #solution(x,y) : x, y에서 도착지점까지 가는 경로의 수
    if x == m-1 and y == n-1: #목표 도달검사
        return 1 #Q.1인 이유 정확히? 모르겠다

    if dp[x][y] == -1: #dp배열 미등록된 경우
                       # -1초기화 이유 : if 0초기화 -> 진짜 경로의 개수가 없어서(0)인지, 미등록된 상태인지(해당지점(x,y)부터 목표지점까지의 경로의 개수값이 '구해지지 않은 상태')인건지 구분 불가능
        dp[x][y] = 0 #

        for i in range(4):
            dr_x, dr_y = x + dx[i], y + dy[i]

            if 0 <= dr_x < m and 0 <= dr_y < n : #범위검사
                if maps[dr_x][dr_y] < maps[x][y] : #유효성검사 - 다음좌표로 이동가능하다면
                    dp[x][y] += solution(dr_x, dr_y) #이동전 좌표2목표지점까지의 경로의수 = 이동전 좌표2목표지점까지의 경로의수 + 이동후 좌표2목표지점까지의 경로의수
    
    return dp[x][y] #'dp배열 등록된 경우'가 의미하는 것 : 해당 지점(x,y)부터 목표지점까지의 경로의 개수값이 '구해졌다'(by x==m-1, y==n-1까지 도달해서)
        
    
print(solution(0, 0))

